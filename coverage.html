
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/AnatolySnegovskiy/metric/cmd/agent/config.go (100.0%)</option>
				
				<option value="file1">github.com/AnatolySnegovskiy/metric/cmd/agent/main.go (25.0%)</option>
				
				<option value="file2">github.com/AnatolySnegovskiy/metric/internal/entity/metrics/counter.go (100.0%)</option>
				
				<option value="file3">github.com/AnatolySnegovskiy/metric/internal/entity/metrics/gauge.go (100.0%)</option>
				
				<option value="file4">github.com/AnatolySnegovskiy/metric/internal/services/agent/agent.go (100.0%)</option>
				
				<option value="file5">github.com/AnatolySnegovskiy/metric/internal/services/agent/metrics.go (0.0%)</option>
				
				<option value="file6">github.com/AnatolySnegovskiy/metric/internal/services/agent/run.go (0.0%)</option>
				
				<option value="file7">github.com/AnatolySnegovskiy/metric/internal/services/agent/update.go (0.0%)</option>
				
				<option value="file8">github.com/AnatolySnegovskiy/metric/internal/services/server/handlers.go (79.2%)</option>
				
				<option value="file9">github.com/AnatolySnegovskiy/metric/internal/services/server/server.go (88.9%)</option>
				
				<option value="file10">github.com/AnatolySnegovskiy/metric/internal/storages/mem_storage.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "strconv"
)

type Config struct {
        flagSendAddr   string
        reportInterval int
        pollInterval   int
}

func NewConfig() (*Config, error) <span class="cov8" title="1">{
        c := &amp;Config{
                flagSendAddr:   "localhost:8080",
                reportInterval: 10,
                pollInterval:   2,
        }

        if err := c.parseFlags(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

func (c *Config) parseFlags() error <span class="cov8" title="1">{
        if val, ok := os.LookupEnv("ADDRESS"); val != "" &amp;&amp; ok </span><span class="cov8" title="1">{
                c.flagSendAddr = val
        }</span>

        <span class="cov8" title="1">var err error
        if v, ok := os.LookupEnv("REPORT_INTERVAL"); v != "" &amp;&amp; ok </span><span class="cov8" title="1">{
                if c.reportInterval, err = strconv.Atoi(v); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("ENV REPORT_INTERVAL: %s", err)
                }</span>
        }
        <span class="cov8" title="1">if v, ok := os.LookupEnv("POLL_INTERVAL"); v != "" &amp;&amp; ok </span><span class="cov8" title="1">{
                if c.pollInterval, err = strconv.Atoi(v); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("ENV POLL_INTERVAL: %s", err)
                }</span>
        }

        <span class="cov8" title="1">flag.StringVar(&amp;c.flagSendAddr, "a", c.flagSendAddr, "address and port to run server")
        flag.IntVar(&amp;c.reportInterval, "r", c.reportInterval, "reportInterval description")
        flag.IntVar(&amp;c.pollInterval, "p", c.pollInterval, "pollInterval description")
        flag.Parse()

        if flag.NArg() &gt; 0 </span><span class="cov8" title="1">{
                flag.PrintDefaults()
                return fmt.Errorf("%s", flag.Arg(0))
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "github.com/AnatolySnegovskiy/metric/internal/entity/metrics"
        "github.com/AnatolySnegovskiy/metric/internal/services/agent"
        "github.com/AnatolySnegovskiy/metric/internal/storages"
        "log"
        "os"
        "os/signal"
        "syscall"
)

func handleError(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                os.Exit(1)
        }</span>
}

func handleShutdownSignal(quit chan os.Signal) <span class="cov8" title="1">{
        &lt;-quit
        fmt.Println("Agent stopped")
        os.Exit(0)
}</span>

func main() <span class="cov0" title="0">{
        s := storages.NewMemStorage()
        s.AddMetric("gauge", metrics.NewGauge())
        s.AddMetric("counter", metrics.NewCounter())

        quit := make(chan os.Signal, 1)
        signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
        go handleShutdownSignal(quit)

        fmt.Println("Agent started")
        c, err := NewConfig()
        handleError(err)

        handleError(
                agent.New(
                        agent.Options{
                                Storage:        s,
                                PollInterval:   c.pollInterval,
                                ReportInterval: c.reportInterval,
                                SendAddr:       c.flagSendAddr,
                        },
                ).Run(context.Background()))
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package metrics

import (
        "errors"
        "strconv"
)

type Counter struct {
        items map[string]float64
}

func (c *Counter) Process(name string, data string) error <span class="cov8" title="1">{
        intValue, err := strconv.ParseInt(data, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("metric value is not int")
        }</span>

        <span class="cov8" title="1">c.items[name] += float64(intValue)
        return nil</span>
}

func (c *Counter) GetList() map[string]float64 <span class="cov8" title="1">{
        return c.items
}</span>

func NewCounter() *Counter <span class="cov8" title="1">{
        return &amp;Counter{
                items: make(map[string]float64),
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package metrics

import (
        "errors"
        "strconv"
)

type Gauge struct {
        items map[string]float64
}

func (g *Gauge) Process(name string, data string) error <span class="cov8" title="1">{
        floatValue, err := strconv.ParseFloat(data, 64)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("metric value is not float64")
        }</span>

        <span class="cov8" title="1">g.items[name] = floatValue
        return nil</span>
}

func (g *Gauge) GetList() map[string]float64 <span class="cov8" title="1">{ return g.items }</span>

func NewGauge() *Gauge <span class="cov8" title="1">{
        return &amp;Gauge{
                items: make(map[string]float64),
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package agent

import (
        "time"
)

type Agent struct {
        storage        Storage
        pollInterval   &lt;-chan time.Time
        reportInterval &lt;-chan time.Time
        flagSendAddr   string
}

type Options struct {
        Storage        Storage
        PollInterval   int
        ReportInterval int
        SendAddr       string
}

func New(options Options) *Agent <span class="cov8" title="1">{
        return &amp;Agent{
                storage:        options.Storage,
                pollInterval:   time.Tick(time.Duration(options.PollInterval) * time.Second),
                reportInterval: time.Tick(time.Duration(options.ReportInterval) * time.Second),
                flagSendAddr:   options.SendAddr,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package agent

import (
        "context"
        "fmt"
        "net/http"
)

func sendMetricsPeriodically(ctx context.Context, addr string, s Storage) error <span class="cov0" title="0">{
        for storageType, storage := range s.GetList() </span><span class="cov0" title="0">{
                for metricName, metric := range storage.GetList() </span><span class="cov0" title="0">{
                        err := sendMetric(ctx, addr, storageType, metricName, metric)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func sendMetric(ctx context.Context, addr string, storageType string, name string, metric any) error <span class="cov0" title="0">{
        url := fmt.Sprintf("http://%s/update/%s/%s/%v", addr, storageType, name, metric)
        req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package agent

import (
        "context"
        "fmt"
        "log"
)

func (a *Agent) Run(ctx context.Context) error <span class="cov0" title="0">{
        s := a.storage

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                case &lt;-a.pollInterval:<span class="cov0" title="0">
                        err := updateStoragePeriodically(s)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error occurred while updating storage: %w", err)
                        }</span>
                        <span class="cov0" title="0">log.Println("storage updated")</span>
                case &lt;-a.reportInterval:<span class="cov0" title="0">
                        err := sendMetricsPeriodically(ctx, a.flagSendAddr, s)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error occurred while sending metrics: %w", err)
                        }</span>
                        <span class="cov0" title="0">log.Println("metrics sent")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package agent

import (
        "fmt"
        "reflect"
        "runtime"
        "time"
)

var m runtime.MemStats
var runtimeEntityArray = []string{"Alloc", "BuckHashSys", "Frees", "GCCPUFraction", "GCSys", "HeapAlloc", "HeapIdle", "HeapInuse",
        "HeapObjects", "HeapReleased", "HeapSys", "LastGC", "Lookups", "MCacheInuse", "MCacheSys", "MSpanInuse",
        "MSpanSys", "Mallocs", "NextGC", "NumForcedGC", "NumGC", "OtherSys", "PauseTotalNs", "StackInuse",
        "StackSys", "Sys", "TotalAlloc"}

func updateStoragePeriodically(storage Storage) error <span class="cov0" title="0">{
        runtime.ReadMemStats(&amp;m)

        gauge, err := storage.GetMetricType("gauge")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting gauge: %w", err)
        }</span>

        <span class="cov0" title="0">counter, err := storage.GetMetricType("counter")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting counter: %w", err)
        }</span>

        <span class="cov0" title="0">if counter.Process("PollCount", "1") != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while processing field: PollCount")
        }</span>
        <span class="cov0" title="0">if gauge.Process("RandomValue", fmt.Sprintf("%v", time.Now().UnixNano())) != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while processing field: RandomValue")
        }</span>

        <span class="cov0" title="0">for _, field := range runtimeEntityArray </span><span class="cov0" title="0">{
                if gauge.Process(field, fmt.Sprintf("%v", reflect.ValueOf(m).FieldByName(field))) != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error while processing field: %s", field)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package server

import (
        "fmt"
        "github.com/go-chi/chi/v5"
        "net/http"
)

func (s *Server) writeMetricHandlers(rw http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        metricType := chi.URLParam(req, "metricType")
        metricName := chi.URLParam(req, "metricName")
        metricValue := chi.URLParam(req, "metricValue")

        if metricType == "" || metricName == "" || metricValue == "" </span><span class="cov0" title="0">{
                http.Error(rw, "metric name is required", http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">storage := s.storage
        metric, err := storage.GetMetricType(metricType)

        if err != nil </span><span class="cov8" title="1">{
                http.Error(rw, fmt.Sprintf("metric type %s not found", metricType), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := metric.Process(metricName, metricValue); err != nil </span><span class="cov8" title="1">{
                http.Error(rw, fmt.Sprintf("failed to process metric: %s", err.Error()), http.StatusBadRequest)
                return
        }</span>
}

func (s *Server) showAllMetricHandlers(rw http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        stgList := s.storage.GetList()

        if len(stgList) == 0 </span><span class="cov0" title="0">{
                s.notFoundHandler(rw, req)
                return
        }</span>

        <span class="cov8" title="1">for storageType, storage := range stgList </span><span class="cov8" title="1">{
                fmt.Fprintf(rw, "%s:\n", storageType)
                for metricName, metric := range storage.GetList() </span><span class="cov8" title="1">{
                        fmt.Fprintf(rw, "\t%s: %v\n", metricName, metric)
                }</span>
        }
}

func (s *Server) showMetricTypeHandlers(rw http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        metricType := chi.URLParam(req, "metricType")

        if metricType == "" </span><span class="cov0" title="0">{
                s.notFoundHandler(rw, req)
                return
        }</span>

        <span class="cov8" title="1">storage, err := s.storage.GetMetricType(metricType)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(rw, fmt.Sprintf("metric type %s not found", metricType), http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(rw, "%s:\n", metricType)
        for metricName, metric := range storage.GetList() </span><span class="cov8" title="1">{
                fmt.Fprintf(rw, "\t%s: %v\n", metricName, metric)
        }</span>
}

func (s *Server) showMetricNameHandlers(rw http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        metricType := chi.URLParam(req, "metricType")
        metricName := chi.URLParam(req, "metricName")

        if metricType == "" || metricName == "" </span><span class="cov0" title="0">{
                s.notFoundHandler(rw, req)
                return
        }</span>

        <span class="cov8" title="1">storage, err := s.storage.GetMetricType(metricType)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(rw, fmt.Sprintf("metric type %s not found", metricType), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">metric := storage.GetList()[metricName]

        if metric == 0 </span><span class="cov8" title="1">{
                s.notFoundHandler(rw, req)
                return
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(rw, "%v", storage.GetList()[metricName])</span>
}

func (s *Server) notFoundHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        w.WriteHeader(http.StatusNotFound)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package server

import (
        "github.com/AnatolySnegovskiy/metric/internal/storages"
        "github.com/go-chi/chi/v5"
        "net/http"
)

//go:generate mockgen -source=server.go -destination=mocks/server_mock.go -package=mocks
type Storage interface {
        GetMetricType(metricType string) (storages.EntityMetric, error)
        AddMetric(metricType string, metric storages.EntityMetric)
        GetList() map[string]storages.EntityMetric
}

type Server struct {
        storage Storage
        router  *chi.Mux
}

func New(s Storage) *Server <span class="cov8" title="1">{
        server := &amp;Server{
                storage: s,
                router:  chi.NewRouter(),
        }
        server.setupRoutes()
        return server
}</span>

func (s *Server) setupRoutes() <span class="cov8" title="1">{
        s.router.NotFound(s.notFoundHandler)
        s.router.Post("/update/{metricType}/{metricName}/{metricValue}", s.writeMetricHandlers)
        s.router.Get("/", s.showAllMetricHandlers)
        s.router.Get("/value/{metricType}", s.showMetricTypeHandlers)
        s.router.Get("/value/{metricType}/{metricName}", s.showMetricNameHandlers)
}</span>

func (s *Server) Run(addr string) error <span class="cov0" title="0">{
        return http.ListenAndServe(addr, s.router)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package storages

import (
        "errors"
)

//go:generate mockgen -source=mem_storage.go -destination=mocks/mem_storage_mock.go -package=mocks
type EntityMetric interface {
        Process(name string, data string) error
        GetList() map[string]float64
}

type MemStorage struct {
        metrics map[string]EntityMetric
}

func NewMemStorage() *MemStorage <span class="cov8" title="1">{
        storage := &amp;MemStorage{
                metrics: make(map[string]EntityMetric),
        }
        return storage
}</span>

func (m *MemStorage) AddMetric(metricType string, metric EntityMetric) <span class="cov8" title="1">{
        m.metrics[metricType] = metric
}</span>

func (m *MemStorage) GetMetricType(metricType string) (EntityMetric, error) <span class="cov8" title="1">{
        mt, ok := m.metrics[metricType]
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.New("metric type not found")
        }</span>

        <span class="cov8" title="1">return mt, nil</span>
}

func (m *MemStorage) GetList() map[string]EntityMetric <span class="cov8" title="1">{
        return m.metrics
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
